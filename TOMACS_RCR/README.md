


## Pre-requisites

- A bash shell.
- A recent C++ compiler (e.g., GNU G++ or clang++) with the conventional Unix-like toolchain (including make).
- Gnuplot version 5.2 (to generate the figures).

## Quick version

Type

```
make plot
```

This should do everything, including generating the final plots in PDF.


## Generation of the data

The generation of the figures and data should be executed on a Linux machine configured for
testing. It is  recommended to turn off TurboBoost or the equivalent, to disable
hyperthreading (since our tests are single threaded) and to set the power policy on
performance (or the equivalent). It is ill-advised to run benchmarks on a regular laptop.

The benchmark verifies that the average of X runs is equal to the mean of X runs within one percent.
When that it is not the case, a warning is issued. It is normal to get such warning for tiny arrays (containing
10 elements), but if you get such warnings for more sizeable arrays, then your results are likely flawed.


Type:

```
make benchmark
```

Assuming that you meet the prerequisites, this will build a ``shuffle`` executable and then run it, outputting the result to a file called ``results.txt``. This file contains several columns. You do not need to manually process these columns.

The command will fail if you do not have a recent C++ compiler available.

The benchmark will take several minutes to run. Be patient. Each test is run at least 5 times (sometimes more).

## Generation of the figures (PDF files)

To generate the figures, simply type:

```
make plot
```

Make sure you have gnuplot installed, otherwise this will fail. On macOS, you can install gnuplot with ``brew install gnuplot --with-cairo`` (after installing brew itself from https://brew.sh. Under Linux, installing gnuplot could be as simple as typing ``sudo apt-get install gnuplot``.

All figures are generated by the gnuplot script called ``shuffle.gnuplot`` found in the
subdirectory ``gnuplot``. This script presumes that you have generate the ``results.txt``
file by running the benchmark.

Figure 2 (Ratio of the timings of the OpenBSD-like approach and of our approach)
is given by file ``shuffleratio.pdf``.


Figure 3 (Wall-clock time in nanoseconds per element to shuffle arrays of random integers)
 is made of two subfigures given by file ``shuffle32.pdf`` (32-bit indexes)  and file ``shuffle64.pdf`` (64-bit indexes).


Figure 4 (Wall-clock time in nanoseconds per element to shuffle arrays of random integers using either regular shuffles or buffered shuffles with a buffer of size 256) is made of two subfigures given by file ``shuffle32precompopenbsd.pdf`` (32-bit indexes)
 and file ``shuffle64precompopenbsd.pdf`` (64-bit indexes).


Figure 5 (Wall-clock time in nanoseconds per element to shuffle arrays of random integers using either ...) contains
two subfigures given by file ``floatshuffle32.pdf`` (32-bit indexes) and file ``floatshuffle64.pdf`` (64-bit indexes).
